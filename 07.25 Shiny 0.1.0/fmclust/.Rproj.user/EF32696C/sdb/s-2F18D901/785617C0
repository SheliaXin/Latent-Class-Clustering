{
    "collab_server" : "",
    "contents" : "\nshinyServer(function(input, output, session) {\n  options(stringsAsFactors = TRUE)\n  options(shiny.trace = FALSE)\n\n  # choose dataset\n  dataset <- reactive({\n    if(input$data == 'Example'){\n      updateTabsetPanel(session, \"tabset\", selected = \"Data\")\n      if(input$ExampleData == 'Cars93'){\n        data(Cars93)\n        data <- Cars93[ ,c(3,5,8,10)]\n      }\n    }else if(input$data == 'Upload Dataset' && !is.null(input$LoadData)){\n      updateTabsetPanel(session, \"tabset\", selected = \"Data\")\n      file <- input$LoadData\n      data <- read.csv(file$datapath, stringsAsFactors = TRUE)\n\n    }else if(input$data == 'Simulate Dataset' ){\n      updateNavlistPanel(session, \"tabset\", selected = \"Simulate\")\n      if(!is.null(simudata())){\n        data <- as.data.frame(simudata()$data[,-1, drop=FALSE])\n      }else\n        data <- NULL\n    }else{\n      updateTabsetPanel(session, \"tabset\", selected = \"Data\")\n      data <- NULL }\n    return(data)\n  })\n\n  # show simulate panel while using simulate dataset\n  observe({\n    toggle(condition = input$data == 'Simulate Dataset', selector = \"#tabset li a[data-value=Simulate]\")\n  })\n\n  # choose variables & frequency index\n  choices <- reactive( {                              # choices of variables\n    # valid check\n    validate(\n      need(!is.null(dataset()) , \"Please choose a valid dataset\")\n    )\n    if(!is.null(colnames(dataset()))){\n      c <- as.list(colnames(dataset()))\n    }else\n      c <- paste0(\"V_\", 1:ncol(dataset()))\n    c\n  })\n\n  output$variSelector <- renderUI({                     # select variables\n    checkboxGroupInput(\"VariSelected\", h4(\"Variables:\"),\n                       choices = choices(), selected = choices())\n  })\n\n  output$freqSelector <- renderUI({                    # set frequency index\n    if(input$containFreq){\n      selectInput(\"freq\", h5(\"Frequency Index:\"),\n                  choices()[!choices() %in% input$VariSelected])\n    }\n  })\n\n  output$covariate <- renderUI({                       # set covariates\n    if(input$containCov){\n      checkboxGroupInput(\"CovSelected\", h5(\"Covariates:\"),\n                         choices = choices()[!choices() %in% input$VariSelected])\n    }else{\n      NULL\n    }\n  })\n\n  datasetS <- reactive({                               # dataset with selected variables\n    validate(need(!is.null(input$VariSelected),\"Please choose some variables\"))\n    df <- dataset()[,input$VariSelected, drop = FALSE]\n    if(!is.null(input$CovSelected)){\n      df <- data.frame(df, dataset()[ ,input$CovSelected, drop = FALSE])\n    }\n    df\n  })\n\n  ## test\n  output$test <- renderTable({\n    head(datasetS())\n  })\n\n  # covariate data frame\n  covariates <- reactive({\n    if(!is.null(input$CovSelected)){\n      dataset()[,input$CovSelected, drop = FALSE]\n    }else{\n      NULL\n    }\n\n  })\n\n  output$typeSelector <- renderUI({                    # set variable types\n    L <- list()\n    if(!is.null(dataset()) && !is.null(input$VariSelected)){\n\n      auto <- lapply(dataset(), class)                  #  set automaticly (normal/multinomial)\n      for(i in 1:length(input$VariSelected)){\n        if(auto[[input$VariSelected[i]]] != 'factor')\n          autoSelected <- 'Continuous'\n        else\n          autoSelected <- 'Nominal'\n        L[[i]] <- selectInput(paste0(\"tpVar_\",i), input$VariSelected[i], varChoices ,\n                              selected = autoSelected)\n      }\n      L\n    }})\n\n  # list of variable types\n  variableType <- reactive({\n    Ltype <- vector(\"list\", length(varChoices))\n    names(Ltype) <- varChoices\n    if(length(input$VariSelected)>0){\n      for(i in 1:length(input$VariSelected)){\n        for(j in 1:length(varChoices)){\n          if(input[[paste0(\"tpVar_\",i)]] == varChoices[j])\n            Ltype[[varChoices[j]]] <- append(Ltype[[varChoices[j]]], i)\n        }\n      }\n    }\n    Ltype\n  })\n\n  # define the order for ordinal varibale\n  output$orderSelector <- renderUI({\n    L <- list()\n    l <- length(variableType()[['Ordinal']])\n    if(l >0){\n      for( i in 1:l){\n        j <- variableType()[['Ordinal']][i]\n        M <- levels(as.factor(datasetS()[,j]))\n        L[[i]] <- selectInput(paste0(\"odVar_\",i),\n                              paste0(\"Order of \", colnames(datasetS())[j]),\n                              choices = M, multiple = TRUE)\n      }\n    }\n    L\n  })\n\n  ########################\n  # Main Panel\n  ########################\n\n  ### Data ###\n\n  # OUTPUT: data table\n  output$dataView <- DT::renderDataTable({\n    DT::datatable(datasetS(),\n                  options = list(lengthMenu = c(5, 10, 30), pageLength = 5))\n  })\n\n  # OUTPUT: pairs plot\n  output$dataplot <- renderPlot({\n    if(!is.null(datasetS())){\n      if(input$ggpairs || dim(datasetS())[2]==1){\n        ggpairs(datasetS())\n      }else{\n        if(input$run)\n          pairs(datasetS(), pch = 19, cex = 0.75,\n                col = rainbow( length(unique(mod()@cluster)),alpha = 0.5,\n                               start = 0.6, end = 0.10)[mod()@cluster] )\n        else\n          pairs( datasetS() )\n      }\n    }\n  })\n\n  # OUTPUT: summary table\n  output$dataSummary <- renderTable({\n    if(!is.null(datasetS())){\n      options(digits =3)\n      summary(datasetS())\n    }\n  })\n\n  # recommend&select packages\n  output$pkgs <- renderUI({\n    df <- data.frame(recom = rep(\"(recommend)\",length(cpkgs)),\n                     row.names = cpkgs, stringsAsFactors =FALSE)\n    if( !is.null(variableType()$Continuous) ){\n      df[\"poLCA\",1] <- \"(Cut continuous to nominal)\"\n    }\n    if(!is.null(variableType()$Nominal) || !is.null(variableType()$Ordinal) ){\n      df[\"mclust\",1] <- \"(All as continuous!)\"\n    }\n    pkg <- paste(rownames(df),df$recom)\n    choice <- sapply(cpkgs,list)\n    names(choice) <- pkg\n    recom <-  cpkgs[df[,1]==\"(recommend)\"]\n    checkboxGroupInput(\"Pkgs\", h4(\"Recommend Packages:\"),\n                       choices = choice, selected = recom)\n  })\n\n  observe({\n    toggle(condition = \"flexmix\" %in% input$Pkgs ,\n           selector = \"#Clustering li a[data-value=flexmix]\")\n  })\n\n  observe({\n    toggle(condition = \"poLCA\" %in% input$Pkgs ,\n           selector = \"#Clustering li a[data-value=poLCA]\")\n  })\n\n  observe({\n    toggle(condition = \"mclust\" %in% input$Pkgs ,\n           selector = \"#Clustering li a[data-value=mclust]\")\n  })\n\n  ### Clustering ###\n  # add frequency [space cost; to improve!!]\n  dataPre <- eventReactive(input$run, {\n    if(input$containFreq == TRUE){\n      df <- datasetS()\n      df <- df[rep(seq_len(nrow(df)), as.integer(dataset()[,input$freq])),]\n    }else\n      df <- datasetS()\n    df\n  })\n\n  #  flexmix Model & Algorithm\n  mfclusters <- eventReactive(input$run, {\n\n    # use self-defined order\n    ord = NULL\n    if(length(variableType()$Ordinal) >0){\n      ord <- vector(\"list\", length(variableType()$Ordinal))\n      for(i in 1:length(variableType()$Ordinal)){\n        newOrd <- input[[paste0(\"odVar_\",i)]]\n        oldOrd <- levels(as.factor(datasetS()[,variableType()$Ordinal[i]]))\n        if(!is.null(newOrd) && length(newOrd) == length(oldOrd)){\n          ord[[i]] <- newOrd\n        }else{\n          ord[[i]] <- oldOrd\n        }\n      }\n    }\n\n    if(!is.null(input$CovSelected)){\n      concomitant =  which(colnames(dataPre()) == input$CovSelected)\n    }else{\n      concomitant = NULL\n    }\n\n    res <- fmclust(dataPre(),\n                   concomitant = concomitant,\n                   continuous = variableType()$Continuous,\n                   ordinal = variableType()$Ordinal,\n                   nominal = variableType()$Nominal,\n                   count = variableType()$Count_Poisson, order=ord,\n                   nClust = input$nCluster[1]:input$nCluster[2],\n                   diagonal = TRUE)\n    return(res)\n  })\n\n\n  # poLCA Model & Algorithm\n  poclusters <- eventReactive(input$run, {\n\n    data = dataPre()                     # data preparation\n    if(!is.null(variableType()$Continuous)){\n      data[,variableType()$Continuous] <- lapply(data[ , variableType()$Continuous, drop=FALSE],\n                                                 function(x) factor(cut(x,5)))\n    }\n\n    covariate = covariates()              # cut covariates if continuous\n    if(!is.null(covariate)){\n      tem <- lapply(covariates(), factor)\n      dims <- unlist(lapply(tem, function(x) length(levels(x))))\n      for(i in 1:length(dims)){\n        if(dims[i]>10){\n          covariate[,i] <- factor(cut(covariate[ ,i], 5))\n        }\n      }\n    }\n\n    invisible(capture.output(res <- poLCA.mdls(nClust = input$nCluster[1]:input$nCluster[2],\n                                               covariate = covariates(),\n                                               data = data, nrep = 5)))\n    return(res)\n  })\n\n\n  # #mclust\n  # mcclusters <- eventReactive(input$run,{\n  #   Mclust(dataPre(), G = input$nCluster[1]:input$nCluster[2])\n  # })\n\n\n  # Clustering Output\n  # Step 1: summary of all models\n  ## fmclust\n  output$indexSelector <- renderUI({      # UI: choose index [fmclust]\n    checkboxGroupInput(\"indexSelected\", h5(\"Summary Display:\"),\n                       choices = mIndex, selected = dfIndex, inline = T)\n  })\n\n  summaryIndex <- reactive({               # summary stuff [fmclust]\n    validate(\n      need(input$indexSelected > 0, \"Please Choose some Index\")\n    )\n    t <- mfclusters()$summary\n    t[,input$indexSelected, drop = FALSE]\n  })\n\n  output$summary <- DT::renderDataTable({   # Output: summary table [fmclust]\n    DT::datatable(summaryIndex(),\n                  options = list(lengthMenu = c(5, 10, 30), pageLength = 5))\n  })\n\n  output$plotSummary <- renderPlot({        # Output: summary plot [fmclust]\n    plot(mfclusters()$mdls)\n  })\n\n\n  ## poLCA\n  output$poindexSelector <- renderUI({      # UI: choose index [poLCA]\n    checkboxGroupInput(\"poindexSelected\", h5(\"Summary Display:\"),\n                       choices = poIndex, selected = dfIndex, inline = T)\n  })\n\n  posummaryIndex <- reactive({               # summary stuff [poLCA]\n    validate(\n      need(input$poindexSelected > 0, \"Please Choose some Index\")\n    )\n    t <- poclusters()$summary\n    t[,input$poindexSelected, drop = FALSE]\n  })\n\n  output$posummary <- DT::renderDataTable({   # Output: summary table [poLCA]\n    DT::datatable(posummaryIndex(),\n                  options = list(lengthMenu = c(5, 10, 30), pageLength = 5))\n  })\n\n  output$poplotSummary <- renderPlot({        # Output: summary plot [fmclust]\n    df <- poclusters()$summary[,c(\"AIC\",\"BIC\")]\n    minIdx <- apply(df, 2, which.min)\n    ylim <- c(min(df), max(df))\n    plot(poclusters()$nClust, df[,\"AIC\"], type = \"b\", col = \"black\", ylim = ylim, cex = 0.8,\n         xlab = \"number of components\", ylab = \"\")\n    points(poclusters()$nClust[minIdx[\"AIC\"]], df[minIdx[\"AIC\"],\"AIC\"],\n           pch = 19, col = \"black\")\n    lines(poclusters()$nClust, df[,\"BIC\"], type =\"b\", col= \"red\", pch = 2, cex = 0.7)\n    points(poclusters()$nClust[minIdx[\"BIC\"]], df[minIdx[\"BIC\"],\"BIC\"],\n           pch = 19, col = \"red\")\n    legend(\"topright\", legend = c(\"AIC \", \"BIC \"), col= c(\"black\", \"red\"),\n           pch = c(1,2), cex = 0.75)\n  })\n\n  # Step 2: choose one model and show details\n  ## fmclust\n  output$nclust <- renderUI({               # UI: choose model by # cluster\n    selectInput(\"Nclust\", \"Number of cluster\",\n                choices = as.character(input$nCluster[1]:input$nCluster[2]))\n  })\n\n  mod <- reactive({                        # Select model by some index\n    if(input$mChoose != \"Number of cluster\")\n      m <- getModel(mfclusters()$mdls, which = input$mChoose)\n    else\n      m <- getModel(mfclusters()$mdls, which = input$Nclust)\n    m\n  })\n\n  prof <- reactive({                       # profile\n    profile(mod(), mfclusters()$cc)\n  })\n\n  output$plot1 <- renderPlotly({          # Output: profile plot\n    a <- list(                            ## xaxis style\n      title = \"\",\n      showticklabels = TRUE,\n      tickangle = 20,\n      tickfont = list(size = 10, color = \"black\")\n    )\n\n    df <- cbind('id' = rownames(prof()$dfPlt), prof()$dfPlt)\n    data_long <- as.data.frame(melt(df, id = \"id\"), stringsAsFactors = F)\n\n    p <- data_long %>%\n      plot_ly(x = id, y = value,  color = variable) %>%\n      layout(xaxis = a)\n  })\n\n  output$profile <- renderTable({        # Output: profile table\n    d <- prof()$dfPro\n    if(mfclusters()$cc$con.len >0 && !input$detail){\n      exRow <- as.vector(sapply(1:mfclusters()$cc$con.len,\n                                function(x) 1 + 2:6 + (x-1) * 6))\n      return(d[-exRow,])\n    }else\n      return(d)\n  },include.rownames=FALSE)\n\n  output$probMeans <- renderTable({     # Output: probmean table\n    d <- prof()$dfPrM\n    if(mfclusters()$cc$con.len >0 && !input$detail1){\n      exRow <- as.vector(sapply(1:mfclusters()$cc$con.len,\n                                function(x) 1 + 2:6 + (x-1) * 6))\n      return(d[-exRow,])\n    }else\n      return(d)\n  },include.rownames=FALSE)\n\n  ## poLCA\n  output$ponclust <- renderUI({               # UI: choose model by # cluster\n    selectInput(\"poNclust\", \"Number of cluster\",\n                choices = as.character(input$nCluster[1]:input$nCluster[2]))\n  })\n\n  poMod <- reactive({                        # Select model by some index\n    if(input$pomChoose != \"Number of cluster\")\n      m <- poGetModel(poclusters(), which = input$pomChoose)\n    else\n      m <- poGetModel(poclusters(), which = input$poNclust)\n    m\n  })\n\n  output$poplot <- renderPlotly({          # Output: profile plot\n    a <- list(                            ## xaxis style\n      title = \"\",\n      showticklabels = TRUE,\n      tickangle = 20,\n      tickfont = list(size = 10, color = \"black\")\n    )\n\n    df <- data.frame('id' = rownames(poMod()$plot), poMod()$plot)\n    data_long <- as.data.frame(melt(df, id = \"id\"), stringsAsFactors = F)\n\n    p <- data_long %>%\n      plot_ly(x = id, y = value,  color = variable) %>%\n      layout(xaxis = a)\n  })\n\n  output$poprofile <- renderTable({        # Output: profile table\n    d <- poMod()$profile\n  },include.rownames=FALSE)\n\n  output$poprobMeans <- renderTable({     # Output: probmean table\n    d <- poMod()$probMeans\n  },include.rownames=FALSE)\n\n  # mclust\n\n  mcdata <- reactive({\n    as.data.frame(lapply(dataPre(), as.numeric))\n  })\n\n  mcmdls <- reactive({\n    Mclust(mcdata(), G = input$nCluster[1]:input$nCluster[2])\n  })\n\n  mcBIC <- reactive({\n    if(input$mcifBIC == \"ICL\"){\n      res <- mclustICL(mcdata(), G = input$nCluster[1]:input$nCluster[2])\n    }else{\n      res <- mcmdls()$BIC\n    }\n    res\n  })\n\n  # BIC/ICL summary table\n  mcBICtable <- reactive({\n    x <- mcBIC()\n    Glabels <- dimnames(x)[[1]]\n    modelNames <- dimnames(x)[[2]]\n    x <- matrix(as.vector(x), nrow = length(Glabels), ncol =length(modelNames))\n    rownames(x) <- Glabels\n    colnames(x) <- modelNames\n    x\n  })\n\n  output$mcBICsum <- DT::renderDataTable({\n    mcBICtable()\n  }, options = list(scrollX = TRUE, dom = 't' ))\n\n\n  # BIC/ICL plot\n  output$mcplot <- renderPlot({\n    plot( mcBIC())\n  })\n\n\n  # Choose model and cluster\n  output$mcModel <- renderUI({\n    L <- list()\n    tem <- unlist(strsplit(names(summary(mcBIC())[1]),\",\"))\n    L[[1]] <- selectInput(\"mcmodel\",\"Choose Model:\", choices = colnames(mcBICtable()),\n                          selected = tem[1])\n    L[[2]] <- selectInput(\"mcclust\",\"Choose Clust:\", choices = rownames(mcBICtable()),\n                          selected = tem[2])\n    L\n  })\n\n  mcmod <- reactive({\n    Mclust(mcdata(), G = input$mcclust, modelNames = input$mcmodel)\n  })\n\n  output$mcSum <- renderTable({\n    res <- rbind(summary(mcBIC()))\n    res\n  })\n\n  output$mcprofile <- renderTable({\n    rbind( \"size\"= mcmod()$parameters$pro, mcmod()$parameters$mean)\n  })\n\n  output$mcProfilePlot <- renderPlotly({\n    a <- list(                            ## xaxis style\n      title = \"\",\n      showticklabels = TRUE,\n      tickangle = 20,\n      tickfont = list(size = 10, color = \"black\")\n    )\n    df <- mcmod()$parameters$mean\n    dfmax <- apply(mcdata(),2,max)\n    dfmin <- apply(mcdata(),2,min)\n    df <- data.frame('id' = rownames(df), (df-dfmin)/(dfmax-dfmin))\n    data_long <- as.data.frame(melt(df, id = \"id\"), stringsAsFactors = F)\n\n    p <- data_long %>%\n      plot_ly(x = id, y = value,  color = variable) %>%\n      layout(xaxis = a)\n  })\n\n\n  output$mcplot1 <- renderPlot({\n    plot(mcmod(), what = \"classification\")\n  })\n\n\n\n  ### Output ###\n\n  dfClust <- reactive({                   # data frame with cluster\n    cbind(dataset(), cIdx = mod()@cluster )\n  })\n\n  datasetOutput <- reactive({             # choose output data frame\n    switch(input$outputSet,\n           \"Dataset (with cluster)\" = dfClust(),\n           \"Profile\" = prof()$dfPro,\n           \"ProbMeans\"= prof()$dfPrM)\n  })\n\n  output$downloadOutput <- downloadHandler(  # downloader\n    filename = function() { paste(input$outputSet, '.csv', sep ='')},\n    content = function(file){\n      write.csv(datasetOutput(), file)\n    })\n\n\n  ### Simulate ###\n  output$sizeSelector <- renderUI({       # UI: choose size for each group\n    L <- list()\n    for(i in 1:ngroup_s()){\n      L[[i]] <- column(width = 2, numericInput(paste0('size',i), paste0('group',i),\n                                               value = 50, min = 1, step = 1))\n    }\n    L\n  })\n\n  output$cateOrd <- renderUI({            # UI: choose categories for each ordincal variable\n    L <- list()\n    if(input$defineDT && input$nord > 0){\n      L[[1]] <- h4('Categories of each ordinal variables:')\n      for(i in 1:input$nord){\n        L[[i+1]] <- column(width = 2, numericInput(paste0('cateOrd',i), paste0('Variable',i),value = 3, min = 2, step = 1))\n      }\n    }\n    L\n  })\n\n  output$cateNom <- renderUI({            # UI: choose categories for each nominal variable\n    L <- list()\n    if(input$defineDT && input$nnom > 0){\n      L[[1]] <- h4('Categories of each nominal variables:')\n      for(i in 1:input$nnom){\n        L[[i+1]] <- column(width = 2, numericInput(paste0('cateNom',i), paste0('Variable',i),value = 3, min = 2, step = 1))\n      }\n    }\n    L\n  })\n\n  ngroup_s <- reactive({                     # Number of group\n    validate(                                ## valid check\n      need(!is.na(input$ngroup) && input$ngroup >= 1,\n           \"Please enter a valid number of groups\")\n    )\n    as.integer(input$ngroup)\n  })\n\n  size_s <- reactive({                        # size of each group\n    size <- c()\n    for(i in 1:ngroup_s()){\n      temp <- input[[paste0('size',i)]]\n      validate(need(!is.na(temp) && temp >= 1,  \"Invalid number of size\"))\n      size <- c(size, as.integer(temp))\n    }\n    size\n  })\n\n  # simulate parameters\n  simupara <- reactive({\n    size <- size_s()\n    podim = NULL\n    ppdim = NULL\n\n    validate(\n      need(input$ncont+input$nord+input$nnom+input$ncount > 0,\n           \"Invalid number of variables\")\n    )\n\n    if(input$defineDT){\n      if(input$nord>0){\n        podim <- c()\n        for(j in 1:input$nord){\n          podim <- c(podim, input[[paste0(\"cateOrd\",j)]])\n        }\n      }\n      if(input$nnom>0){\n        ppdim <- c()\n        for(j in 1:input$nnom){\n          ppdim <- c(ppdim, input[[paste0(\"cateNom\",j)]])\n        }\n      }\n    }\n\n    DF <- simuData(ngroup = ngroup_s(), size = size,\n                   cont = input$ncont, ord = input$nord, nom = input$nnom, count = input$ncount,\n                   podim = podim, ppdim = ppdim)\n    DF$statistics\n  })\n\n  # define parameters for each variable (handsontable)\n  values = reactiveValues()\n\n  data1 = reactive({\n    DF = as.data.frame(t(simupara()))\n    if (!is.null(input$hot) ){\n      DFnew = hot_to_r(input$hot)\n      if(all(rownames(DFnew) == rownames(DF)))\n        DF = DFnew\n    }\n    values[[\"para\"]] = DF\n    DF\n  })\n\n  output$hot <- renderRHandsontable({\n    if(input$defineDT){\n      DF = data1()\n      rhandsontable(DF, stretchH = \"all\", rowHeaderWidth = 100)\n    }\n  })\n\n  # simulate data\n  simudata <- reactive({\n    size <- size_s()\n    center = NULL; var = NULL\n    centerOrd = NULL; varOrd = NULL; podim = NULL\n    paraNom = NULL; ppdim = NULL; lambda = NULL\n    s <- 1\n    validate(\n      need(input$ncont+input$nord+input$nnom+input$ncount > 0,\n           \"Invalid number of variables\")\n    )\n\n    if(input$defineDT){                 # if defined parameters, use these self-defined parameters\n\n      df <- as.data.frame(t( data1()))\n      if(input$ncont>0){\n        center <- df[,2:(1+input$ncont), drop = FALSE]; s <- s+input$ncont\n        var <- df[,(s+1):(s + input$ncont), drop = FALSE]; s<- s+input$ncont\n      }\n      if(input$nord>0){\n        centerOrd <- df[,(s+1):(s+input$nord),drop = FALSE]; s <- s+input$nord\n        varOrd <- df[,(s+1):(s+input$nord),drop = FALSE]; s <- s+input$nord\n        podim <- c()\n        for(j in 1:input$nord){\n          podim <- c(podim, input[[paste0(\"cateOrd\",j)]])\n        }\n      }\n      if(input$nnom>0){\n        ppdim <- c()\n        for(j in 1:input$nnom){\n          ppdim <- c(ppdim, input[[paste0(\"cateNom\",j)]])\n        }\n        paraNom <- list()\n        for(i in 1:input$nnom){\n          paraNom[[i]] = df[, (s+1):(s+ppdim[i])]\n          s <- s+ppdim[i]\n        }\n      }\n      if(input$ncount >0){\n        lambda <- df[,(s+1):(s+input$ncount), drop = FALSE]\n      }\n    }\n\n\n    DF <- simuData(ngroup = ngroup_s(), size = size,\n                   cont = input$ncont, ord = input$nord, nom = input$nnom, count = input$ncount,\n                   center = center, var = var,\n                   centerOrd = centerOrd, varOrd = varOrd, podim = podim,\n                   paraNom = paraNom, ppdim = ppdim,\n                   lambda = lambda)\n    DF\n  })\n\n  output$simulatedData <- DT::renderDataTable({   # Simulated data table\n    df <- simudata()$data\n    df[,2:(1+input$ncont)] <- round(df[,2:(1+input$ncont)],2)\n    DT::datatable(df,options = list(scrollX = TRUE, dom = 't' ))\n  })\n\n\n  # clustering table\n  output$fmctable <- renderTable({\n    table(simudata()$data[,1], mod()@cluster)\n  })\n\n  output$fmclustTable <- renderUI({              # cluster table\n    L <- list()\n\n    if(input$data == 'Simulate Dataset' && !is.na(simudata()$data) && length(mod()@cluster) == length(simudata()$data[,1])){\n      L[[1]] <- h3(\"Clustering Table (flexmix):\")\n      L[[2]] <- tableOutput(\"fmctable\")\n    }\n    L\n  })\n\n  # poLCA\n  output$poctable <- renderTable({\n    table(simudata()$data[,1], poMod()$predClust)\n  })\n\n  output$poclustTable <- renderUI({              # cluster table\n    L <- list()\n    if(input$data == 'Simulate Dataset' && !is.na(simudata()$data) && length( poMod()$predClust) == length(simudata()$data[,1])){\n      L[[1]] <- h3(\"Clustering Table (poLCA):\")\n      L[[2]] <- tableOutput(\"poctable\")\n    }\n    L\n  })\n\n  # mclust\n  output$mcctable <- renderTable({\n    table(simudata()$data[,1], mcmod()$classification)\n  })\n\n  output$mcclustTable <- renderUI({              # cluster table\n    L <- list()\n    if(input$data == 'Simulate Dataset' && !is.na(simudata()$data) && length(mcmod()$classification) == length(simudata()$data[,1])){\n      L[[1]] <- h3(\"Clustering Table (mclust):\")\n      L[[2]] <- tableOutput(\"mcctable\")\n    }\n    L\n  })\n\n})\n\n",
    "created" : 1470153268629.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "31|11|33|2|\n36|24|46|2|\n48|35|51|2|\n53|35|58|2|\n60|32|67|2|\n69|24|76|2|\n79|30|81|2|\n84|26|91|2|\n93|35|107|5|\n110|28|122|2|\n125|36|138|2|\n147|42|150|2|\n153|33|166|2|\n169|37|174|2|\n194|11|197|2|\n199|11|202|2|\n204|11|207|2|\n211|39|218|2|\n221|42|253|2|\n257|42|280|2|\n297|28|303|2|\n305|41|308|2|\n321|30|327|2|\n329|43|332|2|\n334|38|347|2|\n351|29|354|2|\n356|19|362|2|\n364|20|366|2|\n384|33|392|2|\n394|35|402|2|\n405|31|408|2|\n418|33|432|2|\n434|35|436|2|\n438|37|440|2|\n603|24|632|2|\n637|20|646|2|\n656|24|706|2|\n",
    "hash" : "2300703429",
    "id" : "785617C0",
    "lastKnownWriteTime" : 1470314437,
    "last_content_update" : 1470314437224,
    "path" : "~/Desktop/customer segmentation/07.25 Shiny 0.1.0/server.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}