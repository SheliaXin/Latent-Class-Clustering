{
    "collab_server" : "",
    "contents" : "# install & require packages\npkgs <- c(\"flexmix\", \"fpc\", \"MASS\",\"mvtnorm\", \"reshape2\", \"devtools\",\"roxygen2\",\n          \"poLCA\",\"mclust\",\"DT\",\n          \"shiny\",\"ggplot2\",\"shinyjs\",\"plotly\",\"xtable\",\n          \"shinythemes\",\"GGally\",\"rhandsontable\")\nnewPkg <- pkgs[!(pkgs %in% installed.packages()[, \"Package\"])]\nif (length(newPkg))\n  install.packages(newPkg, dependencies = TRUE)\nsapply(pkgs, require, character.only = TRUE)\n\ninstall(\"fmclust\")\nlibrary(fmclust)\n\n\n# different choices used in server\nvarChoices  = c(\"Continuous\", \"Nominal\", \"Ordinal\", \"Count_Poisson\")\nmIndex = c(\"logLik\", \"AIC\", \"BIC\", \"ICL\", \"Npar\", \"converged\",\"iter\")\npoIndex = c(\"logLik\", \"AIC\", \"BIC\", \"Npar\", \"df\",\"Chisq\")\ndfIndex = c(\"logLik\", \"AIC\", \"BIC\", \"Npar\")\nExampleDataset = c(\"Mixed Normal and Multinormial\" = \"Cars93\")\nIndex = c(\"AIC\", \"BIC\", \"ICL\")\ncpkgs = c(\"flexmix\",\"poLCA\",\"mclust\")\n\n\n#########\n# reconstruct the ouput of different packages\n###########\n\n\nfmSummary <- function(object){\n  d <- data.frame(iter = sapply(object@models, function(x) x@iter),\n                  converged = sapply(object@models, function(x) x@converged),\n                  Npar = sapply(object@models, function(x) x@df),\n                  k = sapply(object@models, function(x) x@k),\n                  k0 = sapply(object@models, function(x) x@k0),\n                  logLik = sapply(object@models, function(x) logLik(x)),\n                  AIC = AIC(object),\n                  BIC = BIC(object),\n                  ICL = ICL(object))\n  return(d)\n}\n\n### poLCA\npoSummary <- function(obj){\n  d <- data.frame(logLik = obj$llik,\n                  Npar = obj$npar,\n                  df = obj$resid.df,\n                  AIC = obj$aic,\n                  BIC = obj$bic,\n                  Chisq = obj$Chisq)\n  return(d)\n}\n\n\n\n\n# ! check nClust\npoLCA.mdls <- function(nClust, data, covariate = NULL, nrep = 5){\n\n  # formula\n  if(!is.null(covariate)){\n    f <- as.formula(paste(\"cbind(\", paste(setdiff(names(data),names(covariate)), collapse = \",\"), \")~\",\n                          paste(names(covariate), collapse = \"+\")))\n  }else{\n    f <- as.formula(paste(\"cbind(\", paste(names(data), collapse = \",\"), \")~1\"))\n  }\n\n  # models\n  L <- list()\n  L$mdls <- list()\n\n  for(i in 1:length(nClust)){\n    L$mdls[[i]] <- poLCA(f, data, nclass = nClust[i], nrep)\n  }\n\n  L$nClust <- nClust\n\n  # summary\n  L$summary <- do.call(rbind.data.frame, lapply(L$mdls, poSummary))\n  rownames(L$summary) <- nClust\n\n  return(L)\n}\n\npoGetModel <- function(L, which){\n\n  # summary\n  nClust <- L$nClust\n  s <- do.call(rbind.data.frame, lapply(L$mdls, poSummary))\n\n  # get model\n  if(which == \"BIC\"){\n    idx <- which.min(s[,\"BIC\"])\n  }\n  if(which == \"AIC\"){\n    idx <- which.min(s[,\"AIC\"])\n  }\n  if(which %in% as.character(nClust)){\n    idx <- which(which == as.character(nClust))\n  }\n  mdl <- L$mdls[[idx]]\n\n  # dataframe for plot\n  res <- list()\n  res$plot <- t(do.call(cbind.data.frame,mdl$probs))\n\n  # profile\n  len <- unlist(lapply(mdl$probs,ncol))\n  lnames <- rep(\"\",sum(len)+1)\n  lnames[1] <- \"Cluster Size\"\n  lnames[cumsum(len)-len+2] <- names(mdl$probs)\n  names(mdl$probs) <- NULL\n  pro <- t(do.call(cbind.data.frame, mdl$probs ))\n  pro <- rbind(mdl$P, pro)\n  name <- data.frame(Variable = lnames, Categories = row.names(pro) )\n  res$profile <- cbind( name, data.frame( pro, row.names = NULL))\n\n  # probsMeans\n  prm <- lapply(mdl$probs, function(y)  apply(y, 2, function(x) x/sum(x)))\n  prm <- t(do.call(cbind.data.frame, prm ))\n  prm <- rbind(mdl$P, prm)\n  res$probMeans <- cbind(name, data.frame( prm, row.names = NULL))\n\n  # predict class\n  res$predClust <- mdl$predclass\n\n  res$mdl <- mdl\n  return(res)\n}\n\n\n##############\n\n### mclust\nmcSummary <- function(obj){\n  d <- data.frame(logLik = obj$loglik,\n                  Npar = obj$df,\n                  BIC = obj$bic)\n  d\n}\n\nmclust.mdls <- function(data, nClust = 2:5){\n  # models\n  L <- list()\n  L$mdls <- list()\n\n  for(i in 1:length(nClust)){\n    L$mdls[[i]] <- Mclust(data, G = nClust[i])\n  }\n\n  L$nClust <- nClust\n  L$summary <- do.call(rbind.data.frame, lapply(L$mdls, mcSummary))\n  rownames(L$summary) <- nClust\n  return(L)\n}\n\nmcGetModel <- function(L, which){\n  # summary\n  nClust <- L$nClust\n  s <- do.call(rbind.data.frame, lapply(L$mdls, mcSummary))\n  # get model\n  if(which == \"BIC\"){\n    idx <- which.min(s[,\"BIC\"])\n  }\n  if(which %in% as.character(nClust)){\n    idx <- which(which == as.character(nClust))\n  }\n  mdl <- L$mdls[[idx]]\n\n  # dataframe for plot\n  res <- list()\n  res$plot <- t(do.call(cbind.data.frame, mdl$probs))\n\n  # profile\n  len <- unlist(lapply(mdl$probs,ncol))\n  lnames <- rep(\"\",sum(len)+1)\n  lnames[1] <- \"Cluster Size\"\n  lnames[cumsum(len)-len+2] <- names(mdl$probs)\n  names(mdl$probs) <- NULL\n  pro <- t(do.call(cbind.data.frame, mdl$probs ))\n  pro <- rbind(mdl$P, pro)\n  name <- data.frame(Variable = lnames, Categories = row.names(pro) )\n  res$profile <- cbind( name, data.frame( pro, row.names = NULL))\n\n  # probsMeans\n  prm <- lapply(mdl$probs, function(y)  apply(y, 2, function(x) x/sum(x)))\n  prm <- t(do.call(cbind.data.frame, prm ))\n  prm <- rbind(mdl$P, prm)\n  res$probMeans <- cbind(name, data.frame( prm, row.names = NULL))\n\n  # predict class\n  res$predClust <- mdl$predclass\n\n  res$mdl <- mdl\n  return(res)\n}\n",
    "created" : 1470151035952.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3263274151",
    "id" : "5B1DF969",
    "lastKnownWriteTime" : 1470248721,
    "last_content_update" : 1470248721596,
    "path" : "~/Desktop/customer segmentation/07.25 Shiny 0.1.0/global.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}