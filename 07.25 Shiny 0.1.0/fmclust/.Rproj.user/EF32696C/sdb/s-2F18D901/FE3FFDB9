{
    "collab_server" : "",
    "contents" : "#' mcmixed\n#'\n#' This is a M-step used to do clustering in flexmix, it could use to cluster mixed-mode (continuous/ordinal/nominal/count) data\n#' @param formula use default when do clustering\n#' @param continuous number of continuous variables\n#' @param ordinal number of ordinal variables\n#' @param nominal number of nominal variables\n#' @param count.poi number of count variables\n#' @param diagonal whether assume local independence. default TRUE (FALSE set full variance in continuous data)\n#' @param printlik whether print the loglikelihood\n#' @export\n\n\nmcmixed <- function ( formula = .~. , continuous = 0, ordinal = 0, nominal = 0, count.poi =0, ppdim,\n                      diagonal = TRUE, pred.ordinal = FALSE, printlik = FALSE)\n{\n  retval <- new (\"FLXMC\", weighted = TRUE,\n                 formula = formula , dist = \"mixed-mode\",\n                 name = \"latent class for normal/multinomial/poisson mixed data\")\n\n  # check response type (for Poisson)   ### dhouble check !!! ###\n  # retval@preproc.y <- function(x){\n  #   storage.mode(x) <- \"integer\"\n  #   x\n  # }\n\n  retval@defineComponent <- expression ({\n\n    # loglikelihood\n    logLik <- function (x, y) {\n\n      # continuous\n      if (continuous!=0){\n        out <- dmvnorm (as.matrix(y)[ , 1:continuous, drop = FALSE],\n                        mean = center, sigma = cov, log = TRUE )\n      }else{\n        out <- 0}\n\n      # ordinal\n      if(ordinal != 0){\n        ###   use cut probability   ### has problem here!\n        for( k in 1:ordinal){\n          d <- as.matrix(y)[ ,continuous+k]\n\n          perc.cut <- qnorm(c(0, cumsum(table(d)/nrow(y))),\n                            mean = mean(d), sd =  sqrt(var(d)))  # replicate\n          resp.probs <- pnorm(perc.cut[2:length(perc.cut)],\n                              mean = centerOrd[k], sd = sqrt(diag(covOrd)[k]))\n          - pnorm(perc.cut[1:(length(perc.cut)-1)],\n                  mean = centerOrd[k], sd = sqrt(diag(covOrd)[k]))\n          out <- out + log(resp.probs[as.matrix(y)[,continuous+k]])   ###########\n        }\n\n      }\n\n\n      # nominal\n      start = continuous + ordinal\n      if (nominal>0){\n        for (k in 1:nominal)\n          out <- out + log(pp[[k]][y[ , start + k]])\n      }\n\n\n      # poisson\n      start = continuous + ordinal + nominal\n      if(count.poi >0){\n        yy <- as.matrix(y)[ ,(start +1):(start + count.poi), drop = FALSE]\n        out <- out + colSums(dpois(t(yy), lambda, log = TRUE))\n      }\n\n\n      if (printlik){\n        cat(\"LogLikelihood= \",sum(out), \"\\n\")\n        cat(\"pp= \",pp[[k]],\"\\n\") }\n      out }\n\n\n    predict <- function (x) {\n\n      # continuous\n      if (!is.null(center))\n        out <- matrix (center, nrow = nrow (x),\n                       ncol = length(center), byrow = TRUE )\n      else\n        out <- matrix(0, ncol=2, nrow=nrow(x))   ## check why ncol =2\n\n      # ordinal\n      if(!is.null(centerOrd))\n        out <- matrix (centerOrd , nrow = nrow (x),\n                       ncol = length(centerOrd), byrow = TRUE )\n      else\n        out <- matrix(0, ncol=2, nrow=nrow(x))\n\n      # nominal\n      start = continuous + ordinal\n      if (nominal > 0){\n        for (k in 1:nominal){\n          if (pred.ordinal)\n            out[, start + k] <- sum((1:ppdim[k])*pp[[k]])  # if ordinal, use weighted mean ## KEEP?\n          else\n            out[, start + k] <- which.max(pp[[k]])  # else, use mode\n        }}\n\n      # poisson\n      start = continuous + ordinal + nominal\n      if(count.poi >0){\n        out[,( start + 1):(start + count.poi)] <- matrix(lambda, nrow = nrow(x), ncol = length(lambda), byrow = TRUE ) }\n      out }\n\n    if (continuous == 0){\n      center <- NULL\n      cov <- NULL\n    }\n\n    new (\"FLXcomponent\",\n         parameters = list ( center = center , cov = cov ,centerOrd = centerOrd, covOrd = covOrd, pp = pp, lambda = lambda),\n         df = df , logLik = logLik , predict = predict )\n  })\n\n\n  retval@fit <- function (x, y, w) {\n    n <- nrow(x)\n    sw <- sum(w)\n\n    # continuous\n    if (continuous!=0)\n      para <- cov.wt(as.matrix(y)[, 1:continuous, drop=FALSE], wt = w)[c(\"center\", \"cov\")]\n    else\n      para <- list(center=NULL, cov=NULL)\n\n    # ordinal\n    if(ordinal != 0 )\n      para[c(\"centerOrd\", \"covOrd\")] <- cov.wt(as.matrix(y)[, (continuous + 1): (continuous + ordinal), drop=FALSE], wt = w)[c(\"center\", \"cov\")]\n    else\n      para[c(\"centerOrd\", \"covOrd\")] <- list(centerOrd=NULL,covOrd=NULL)\n\n    # nominal\n    para$pp <- list()\n    start = continuous + ordinal\n    if (nominal>0){\n      for (k in 1:nominal){\n        para$pp[[k]] <- numeric(0)\n        for (l in 1:ppdim[k])\n          para$pp[[k]][l] <- sum(w*(as.matrix(y)[, start + k] == l))/sw  ## check!!!\n      }}\n\n    # poisson\n    para$lambda <- list()\n    start = continuous + nominal + ordinal\n    if(count.poi>1)\n      para$lambda <- colSums(w * (as.matrix(y)[ ,(start +1):(start + count.poi)])/sw)\n    else if(count.poi == 1)\n      para$lambda <- sum(w * (as.matrix(y)[ ,(start + 1)])/sw)\n\n    # degree of freedom\n    df <- (3 * continuous + continuous^2)/2\n    if (continuous>0){\n      if ( diagonal ) {\n        if (ncol(para$cov)>1)\n          para$cov <- diag ( diag ( para$cov ))   ## better to put it ahead\n        df <- 2 * continuous\n      }}\n    if(ordinal >0 )\n      df <- df + 2*ordinal # did not consider local dependence\n    if (nominal>0)\n      df <- df + sum(ppdim-1)\n    if(count.poi>0 )\n      df <- df + count.poi\n    # print(df)\n    with (para , eval ( retval@defineComponent ))\n  }\n  retval\n}\n",
    "created" : 1470246169790.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1892499121",
    "id" : "FE3FFDB9",
    "lastKnownWriteTime" : 1470246187,
    "last_content_update" : 1470246187592,
    "path" : "~/Desktop/customer segmentation/07.25 Shiny 0.1.0/fmclust/R/mcmixed.R",
    "project_path" : "R/mcmixed.R",
    "properties" : {
        "source_window_id" : ""
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}