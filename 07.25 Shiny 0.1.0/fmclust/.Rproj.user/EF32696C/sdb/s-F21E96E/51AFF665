{
    "collab_server" : "",
    "contents" : "\nshinyServer(function(input, output, session) {\n  options(stringsAsFactors = TRUE)\n\n  # choose dataset\n  dataset <- reactive({\n    if(input$data == 'Example'){\n      updateTabsetPanel(session, \"tabset\", selected = \"Data\")\n      if(input$ExampleData == 'Cars93'){\n        data(Cars93)\n        data <- Cars93[ ,c(3,5,8,10)]\n      }\n    }else if(input$data == 'Upload Dataset' && !is.null(input$LoadData)){\n      updateTabsetPanel(session, \"tabset\", selected = \"Data\")\n      file <- input$LoadData\n      data <- read.csv(file$datapath)\n\n    }else if(input$data == 'Simulate Dataset' ){\n      updateTabsetPanel(session, \"tabset\", selected = \"Simulate\")\n      if(!is.null(simudata())){\n        data <- as.data.frame(simudata()$data[,-1, drop=FALSE])\n      }else\n        data <- NULL\n    }else{\n      updateTabsetPanel(session, \"tabset\", selected = \"Data\")\n      data <- NULL }\n    return(data)\n  })\n\n\n  # choose variables & frequency index\n  choices <- reactive( {                              # choices of variables\n    # valid check\n    validate(\n      need(!is.null(dataset()) , \"Please choose a valid dataset\")\n    )\n    if(!is.null(colnames(dataset()))){\n      c <- as.list(colnames(dataset()))\n    }else\n      c <- paste0(\"V_\", 1:ncol(dataset()))\n    c\n  })\n\n  output$variSelector <- renderUI({                     # select variables\n    checkboxGroupInput(\"VariSelected\", h4(\"Select Variables:\"),\n                       choices = choices(), selected = choices())})\n\n  output$freqSelector <- renderUI({                    # set frequency index\n    selectInput(\"freq\", h4(\"Frequency Index:\"),\n                c(\"NULL\", choices()[!choices() %in% input$VariSelected]))})\n\n  datasetS <- reactive({                               # dataset with selected variables\n    dataset()[,input$VariSelected, drop = FALSE] })\n\n  output$typeSelector <- renderUI({                    # set variable types\n    L <- list()\n    if(!is.null(dataset()) && !is.null(input$VariSelected)){\n\n      auto <- lapply(dataset(), class)                  #  set automaticly (normal/multinomial)\n      for(i in 1:length(input$VariSelected)){\n\n        if(auto[[input$VariSelected[i]]] != 'factor')\n          autoSelected <- 'Continuous'\n        else\n          autoSelected <- 'Nominal'\n\n        L[[i]] <- selectInput(paste0(\"tpVar_\",i), input$VariSelected[i], varChoices ,\n                              selected = autoSelected)\n      }\n      L\n    }})\n\n  # list of variable types\n  variableType <- reactive({\n    Ltype <- vector(\"list\", length(varChoices))\n    names(Ltype) <- varChoices\n    if(length(input$VariSelected)>0){\n      for(i in 1:length(input$VariSelected)){\n        for(j in 1:length(varChoices)){\n          if(input[[paste0(\"tpVar_\",i)]] == varChoices[j])\n            Ltype[[varChoices[j]]] <- append(Ltype[[varChoices[j]]], i)\n        }\n      }\n    }\n    Ltype\n  })\n\n  # define the order for ordinal varibale\n  output$orderSelector <- renderUI({\n    L <- list()\n    l <- length(variableType()[['Ordinal']])\n    if(l >0){\n      for( i in 1:l){\n        j <- variableType()[['Ordinal']][i]\n        M <- levels(as.factor(datasetS()[,j]))\n        L[[i]] <- selectInput(paste0(\"odVar_\",i),\n                              paste0(\"Order of \", colnames(datasetS())[j]),\n                              choices = M, multiple = TRUE)\n      }\n    }\n    L\n  })\n\n  ########################\n  # Main Panel\n  ########################\n\n  ### Data ###\n\n  # OUTPUT: data table\n  output$dataView <- DT::renderDataTable({\n    DT::datatable(datasetS(),\n                  options = list(lengthMenu = c(5, 10, 30), pageLength = 5))\n  })\n\n  # OUTPUT: pairs plot\n  output$dataplot <- renderPlot({\n    if(!is.null(datasetS())){\n      if(input$ggpairs || dim(datasetS())[2]==1){\n        ggpairs(datasetS())\n      }else{\n        if(input$run)\n          pairs(datasetS(), pch = 19, cex = 0.75,\n                col = rainbow( length(unique(mod()@cluster)),alpha = 0.5,\n                               start = 0.6, end = 0.10)[mod()@cluster] )\n        else\n          pairs( datasetS() )\n      }\n    }\n  })\n\n  # OUTPUT: summary table\n  output$dataSummary <- renderTable({\n    if(!is.null(datasetS())){\n      options(digits =3)\n      summary(datasetS())\n    }\n  })\n\n\n  ### Clustering ###\n  # Model & Algorithm\n  clusters <- eventReactive(input$run, {\n\n    # add frequency [space cost; to improve!!]\n    if(input$freq != \"NULL\"){\n      df <- datasetS()\n      df <- df[rep(seq_len(nrow(df)), as.integer(dataset()[,input$freq])),]\n    }else\n      df <- datasetS()\n\n    # use self-defined order\n    ord = NULL\n    if(length(variableType()$Ordinal) >0){\n      ord <- vector(\"list\", length(variableType()$Ordinal))\n      for(i in 1:length(variableType()$Ordinal)){\n        newOrd <- input[[paste0(\"odVar_\",i)]]\n        oldOrd <- levels(as.factor(datasetS()[,variableType()$Ordinal[i]]))\n        if(!is.null(newOrd) && length(newOrd) == length(oldOrd)){\n          ord[[i]] <- newOrd\n        }else{\n          ord[[i]] <- oldOrd\n        }\n      }\n    }\n\n\n    cc <- data.recode(df, continuous = variableType()$Continuous,\n                      ordinal = variableType()$Ordinal,\n                      nominal = variableType()$Nominal,\n                      count = variableType()$Count_Poisson, order=ord )\n\n    mdl <- initFlexmix(cc$data ~ 1, k = input$nCluster[1]:input$nCluster[2],\n                       model = mcmixed(continuous = cc$con.len,\n                                       ordinal = cc$ord.len,\n                                       nominal = cc$nom.len,\n                                       count.poi = cc$count.len,\n                                       ppdim = cc$ppdim[1:cc$nom.len],\n                                       diagonal = TRUE))\n\n    return(list(cc = cc, mdl = mdl))\n  })\n\n  # Clustering Output\n  output$indexSelector <- renderUI({      # UI: choose index\n    checkboxGroupInput(\"indexSelected\", h4(\"Summary Display:\"),\n                       choices = mIndex, selected = dfIndex,inline = T)\n  })\n\n  summaryIndex <- reactive({               # summary stuff\n    validate(\n      need(input$indexSelected >0, \"Please Choose some Index\")\n    )\n    t <- show(clusters()$mdl)\n    t[,input$indexSelected, drop = FALSE]\n  })\n\n\n  output$summary <- DT::renderDataTable({   # Output: summary table\n    DT::datatable(summaryIndex(),\n                  options = list(lengthMenu = c(5, 10, 30), pageLength = 5))\n  })\n\n  output$plotSummary <- renderPlot({        # Output: summary plot\n    plot(clusters()$mdl)\n  })\n\n  output$nclust <- renderUI({               # UI: choose model by # cluster\n    selectInput(\"Nclust\", \"Number of cluster\",\n                choices = as.character(input$nCluster[1]:input$nCluster[2]))\n  })\n\n  mod <- reactive({                        # Select model by some index\n    if(input$mChoose != \"Number of cluster\")\n      m <- getModel(clusters()$mdl, which = input$mChoose)\n    else\n      m <- getModel(clusters()$mdl, which = input$Nclust)\n    m\n  })\n\n  prof <- reactive({                       # profile\n    profile(mod(), clusters()$cc)\n  })\n\n  output$plot1 <- renderPlotly({          # Output: profile plot\n    a <- list(                            ## xaxis style\n      title = \"\",\n      showticklabels = TRUE,\n      tickangle = 20,\n      tickfont = list(size = 10, color = \"black\")\n    )\n\n    df <- cbind('id' = rownames(prof()$dfPlt), prof()$dfPlt)\n    data_long <- as.data.frame(melt(df, id = \"id\"), stringsAsFactors = F)\n\n    p <- data_long %>%\n      plot_ly(x = id, y = value,  color = variable) %>%\n      layout(xaxis = a)\n  })\n\n  output$profile <- renderTable({        # Output: profile table\n    d <- prof()$dfPro\n    if(clusters()$cc$con.len >0 && !input$detail){\n      exRow <- as.vector(sapply(1:clusters()$cc$con.len,\n                                function(x) 1 + 2:6 + (x-1) * 6))\n      return(d[-exRow,])\n    }else\n      return(d)\n  },include.rownames=FALSE)\n\n  output$probMeans <- renderTable({     # Output: probmean table\n    d <- prof()$dfPrM\n    if(clusters()$cc$con.len >0 && !input$detail1){\n      exRow <- as.vector(sapply(1:clusters()$cc$con.len,\n                                function(x) 1 + 2:6 + (x-1) * 6))\n      return(d[-exRow,])\n    }else\n      return(d)\n  },include.rownames=FALSE)\n\n\n  ### Output ###\n\n  dfClust <- reactive({                   # data frame with cluster\n    cbind(dataset(), cIdx = mod()@cluster )\n  })\n\n  datasetOutput <- reactive({             # choose output data frame\n    switch(input$outputSet,\n           \"Dataset (with cluster)\" = dfClust(),\n           \"Profile\" = prof()$dfPro,\n           \"ProbMeans\"= prof()$dfPrM)\n  })\n\n  output$downloadOutput <- downloadHandler(  # downloader\n    filename = function() { paste(input$outputSet, '.csv', sep ='')},\n    content = function(file){\n      write.csv(datasetOutput(), file)\n    })\n\n\n  ### Simulate ###\n  output$sizeSelector <- renderUI({       # UI: choose size for each group\n    L <- list()\n    for(i in 1:ngroup_s()){\n      L[[i]] <- column(width = 2, numericInput(paste0('size',i), paste0('group',i),\n                                               value = 50, min = 1, step = 1))\n    }\n    L\n  })\n\n  output$cateOrd <- renderUI({            # UI: choose categories for each ordincal variable\n    L <- list()\n    if(input$defineDT && input$nord > 0){\n      L[[1]] <- h4('Categories of each ordinal variables:')\n      for(i in 1:input$nord){\n        L[[i+1]] <- column(width = 2, numericInput(paste0('cateOrd',i), paste0('Variable',i),value = 3, min = 2, step = 1))\n      }\n    }\n    L\n  })\n\n  output$cateNom <- renderUI({            # UI: choose categories for each nominal variable\n    L <- list()\n    if(input$defineDT && input$nnom > 0){\n      L[[1]] <- h4('Categories of each nominal variables:')\n      for(i in 1:input$nnom){\n        L[[i+1]] <- column(width = 2, numericInput(paste0('cateNom',i), paste0('Variable',i),value = 3, min = 2, step = 1))\n      }\n    }\n    L\n  })\n\n  ngroup_s <- reactive({                     # Number of group\n    validate(                                ## valid check\n      need(!is.na(input$ngroup) && input$ngroup >= 1,\n           \"Please enter a valid number of groups\")\n    )\n    as.integer(input$ngroup)\n  })\n\n  size_s <- reactive({                        # size of each group\n    size <- c()\n    for(i in 1:ngroup_s()){\n      temp <- input[[paste0('size',i)]]\n      validate(need(!is.na(temp) && temp >= 1,  \"Invalid number of size\"))\n      size <- c(size, as.integer(temp))\n    }\n    size\n  })\n\n  # simulate parameters\n  simupara <- reactive({\n    size <- size_s()\n    podim = NULL\n    ppdim = NULL\n\n    validate(\n      need(input$ncont+input$nord+input$nnom+input$ncount > 0,\n           \"Invalid number of variables\")\n    )\n\n    if(input$defineDT){\n      if(input$nord>0){\n        podim <- c()\n        for(j in 1:input$nord){\n          podim <- c(podim, input[[paste0(\"cateOrd\",j)]])\n        }\n      }\n      if(input$nnom>0){\n        ppdim <- c()\n        for(j in 1:input$nnom){\n          ppdim <- c(ppdim, input[[paste0(\"cateNom\",j)]])\n        }\n      }\n    }\n\n    DF <- simuData(ngroup = ngroup_s(), size = size,\n                   cont = input$ncont, ord = input$nord, nom = input$nnom, count = input$ncount,\n                   podim = podim, ppdim = ppdim)\n    DF$statistics\n  })\n\n  # define parameters for each variable (handsontable)\n  values = reactiveValues()\n\n  data1 = reactive({\n    DF = as.data.frame(t(simupara()))\n    if (!is.null(input$hot) ){\n      DFnew = hot_to_r(input$hot)\n      if(all(rownames(DFnew) == rownames(DF)))\n        DF = DFnew\n    }\n    values[[\"para\"]] = DF\n    DF\n  })\n\n  output$hot <- renderRHandsontable({\n    if(input$defineDT){\n      DF = data1()\n      rhandsontable(DF, stretchH = \"all\", rowHeaderWidth = 100)\n    }\n  })\n\n  # simulate data\n  simudata <- reactive({\n    size <- size_s()\n    center = NULL; var = NULL\n    centerOrd = NULL; varOrd = NULL; podim = NULL\n    paraNom = NULL; ppdim = NULL; lambda = NULL\n    s <- 1\n    validate(\n      need(input$ncont+input$nord+input$nnom+input$ncount > 0,\n           \"Invalid number of variables\")\n    )\n\n    if(input$defineDT){                 # if defined parameters, use these self-defined parameters\n\n      df <- as.data.frame(t( data1()))\n      if(input$ncont>0){\n        center <- df[,2:(1+input$ncont), drop = FALSE]; s <- s+input$ncont\n        var <- df[,(s+1):(s + input$ncont), drop = FALSE]; s<- s+input$ncont\n      }\n      if(input$nord>0){\n        centerOrd <- df[,(s+1):(s+input$nord),drop = FALSE]; s <- s+input$nord\n        varOrd <- df[,(s+1):(s+input$nord),drop = FALSE]; s <- s+input$nord\n        podim <- c()\n        for(j in 1:input$nord){\n          podim <- c(podim, input[[paste0(\"cateOrd\",j)]])\n        }\n      }\n      if(input$nnom>0){\n        ppdim <- c()\n        for(j in 1:input$nnom){\n          ppdim <- c(ppdim, input[[paste0(\"cateNom\",j)]])\n        }\n        paraNom <- list()\n        for(i in 1:input$nnom){\n          paraNom[[i]] = df[, (s+1):(s+ppdim[i])]\n          s <- s+ppdim[i]\n        }\n      }\n      if(input$ncount >0){\n        lambda <- df[,(s+1):(s+input$ncount), drop = FALSE]\n      }\n    }\n\n\n    DF <- simuData(ngroup = ngroup_s(), size = size,\n                   cont = input$ncont, ord = input$nord, nom = input$nnom, count = input$ncount,\n                   center = center, var = var,\n                   centerOrd = centerOrd, varOrd = varOrd, podim = podim,\n                   paraNom = paraNom, ppdim = ppdim,\n                   lambda = lambda)\n    DF\n  })\n\n  output$simulatedData <- DT::renderDataTable({   # Simulated data table\n    df <- simudata()$data\n    df[,2:(1+input$ncont)] <- round(df[,2:(1+input$ncont)],2)\n    DT::datatable(df,\n                  options = list(lengthMenu = c(5, 10, 30), pageLength = 5,autoWidth = TRUE))\n  })\n\n  output$clustTable <- renderTable({              # cluster table\n    if(input$data == 'Simulate Dataset' && !is.na(simudata()$data) && length(mod()@cluster) == length(simudata()$data[,1]))\n      t <- table(simudata()$data[,1], mod()@cluster)\n  })\n})\n\n",
    "created" : 1469541619890.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2596263980",
    "id" : "51AFF665",
    "lastKnownWriteTime" : 1469470128,
    "last_content_update" : 1469470128,
    "path" : "~/Desktop/customer segmentation/07.25 Shiny 1.0/server.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}