{
    "collab_server" : "",
    "contents" : "library(foreign)\n\ndataset <- read.spss(\"/Users/sheliaxin/Desktop/customer segmentation/Latent Class Modeling/LG5.0/LG50demo/DemoData/gss82white.sav\")\ndf <- as.data.frame(dataset)\ndf\nwrite.csv(df, \"gss83white.csv\", row.names = FALSE)\n\n\n## simulate data\nx1 <- cbind(rnorm(300),\n            sample(0:1, 300, replace = TRUE, prob = c(0.25, 0.75)))\nx2 <- cbind(rnorm(300, mean = 2, sd = 0.5),\n            sample(0:1, 300, replace = TRUE, prob = c(0.75, 0.25)))\nx <- rbind(x1, x2)\ncolnames(x) <- c(\"V1\",\"V2\")\n\ncc <-data.recode(x, continuous = c(1), nominal = c(2))\n#cc <-data.recode(df, ordinal = c(1), nominal  = c(2,3,4))\n\nfcm <- initFlexmix(cc$data ~ 1, k = 2:4,\n                   model = mcmixed(continuous = cc$con.len,\n                                   ordinal = cc$ord.len,\n                                   nominal = cc$nom.len,\n                                   count.poi = cc$count.len,\n                                   ppdim = cc$ppdim[1:cc$nom.len],\n                                   pred.ordinal = TRUE,\n                                   diagonal = TRUE))\n\nfc <- flexmix(cc$data~1, k=3, model = mcmixed(continuous = cc$con.len,\n                                        ordinal = cc$ord.len,\n                                        nominal = cc$nom.len,\n                                        count.poi = cc$count.len,\n                                        ppdim = cc$ppdim[1:cc$nom.len],\n                                        pred.ordinal = TRUE,\n                                        diagonal = TRUE) )\nfcm@cluster\nplot(fcm@cluster)\ntable(fcm@cluster,rep(1:2, c(300,300)))\n\n\nfc@cluster\ntable(fc@cluster,rep(1:2, c(300,300)))\n\n###############\nsize <- c(6,4,7)\ncont =3\nord =2\nnom =2\ncount = 2\ncenter = NULL\nvar = NULL\ncenterOrd = NULL\nvarOrd = NULL\npodim = NULL\nparaNom = NULL\nppdim = NULL\nlambda = NULL\nngroup = 3\n\n\n\n##########\n# Function: simuData\n# Input:\n#      ngroup: number of groups\n#      size: a vector with size of each group\n#      cont/ord/nom/count: number of continuous/ordinal/nominal/count(poisson) variables\n#      center: a matrix of means for each continuous variable in each group (ngroup * cont)\n#      var: a matrix of variances for each continuous variable in each group (ngroup * cont)\n#      centerOrd: a matrix of means for each ordinal variable in each group (ngroup * ord)\n#      var: a matrix of variances for each ordinal variable in each group (ngroup * ord)\n#      podim: vector of number of categories for each ordinal data\n#      paraNom: a list of matrix. In each matrix, element (i,j) indicates the probabilities of each\n\nsimuData <- function(ngroup, size,\n                     cont = 0, ord = 0, nom = 0, count = 0,\n                     center = NULL, var = NULL,\n                     centerOrd = NULL, varOrd = NULL, podim = NULL,\n                     paraNom = NULL, ppdim = NULL,\n                     lambda = NULL, seed = 123){\n  set.seed(seed)\n\n  numCol = cont + ord + nom + count\n  # g <- list()\n  # for(i in 1:ngroup){\n  #   g[[i]] <- matrix(NA, nrow = size[i], ncol = numCol)\n  # }\n\n  g <- matrix(NA, nrow = sum(size), ncol = numCol)\n  g <- cbind(rep(c(1,2,3), size),g)\n  colnames(g) <- paste0(\"V\", c(\"\",1:numCol),\"_\", c( \"Cluster\", rep(\"Cont\", cont), rep(\"Ord\", ord), rep(\"Nom\",nom), rep(\"Count\", count)))\n  stat <- data.frame(size = size )\n  sc <-1\n  # continuous\n  if(cont > 0){\n\n    # center\n    if(!is.null(center)){\n      if(nrow(center) != ngroup || ncol(center) != cont){\n        message(\"Input center of continous variables is not valid, use default\")\n        center = matrix(runif(ngroup*cont,5.0,15.0), nrow = cont)\n      }else{\n        center = center\n      }\n    }else{\n      center = matrix(runif(ngroup*cont,5.0,15.0), nrow = ngroup )\n    }\n\n    # variance\n    #if(!is.null(var) && length(var) == ngroup && all(sapply(var,dim) == c(cont,cont))){\n    if(!is.null(var) && nrow(var) == ngroup && ncol(var) == cont){\n      var = var\n    }else{\n      var = matrix(runif(ngroup*cont,1,3), nrow = ngroup )\n    }\n\n    s <- 0\n    for(i in 1:ngroup){\n      for(j in 1:cont){\n        g[(s+1):(s+size[i]),sc+j] <- rnorm(size[i], mean = center[i,j],sd = var[i,j] )\n      }\n      s <- s+size[i]\n    }\n\n    stat <- stat %>%\n      cbind(center = center) %>%\n      cbind(var = var)\n\n  }\n\n  sc = sc +cont\n  ### sample ordinal\n  if(ord >0){\n    # podim\n    if(is.null(podim) || length(podim) != ord)\n      podim = sample(2:6, ord, replace = TRUE)\n\n    #center, var\n    if(!is.null(centerOrd) && nrow(centerOrd) == ngroup && ncol(centerOrd) ==ord){\n      centerOrd = centerOrd\n    }else{\n      centerOrd = matrix(runif(ngroup*ord,5,15), nrow = ngroup )\n    }\n\n    if(!is.null(varOrd) && nrow(varOrd) == ngroup && ncol(varOrd) == ord){\n      varOrd = varOrd\n    }else{\n      varOrd = matrix(runif(ngroup*ord,1,3), nrow = ngroup )\n    }\n\n    for(j in 1:ord){\n      s<-0\n      for(i in 1:ngroup){\n        g[(s+1):(s+size[i]),sc+j]  <- rnorm(size[i], mean = centerOrd[i,j], sd = varOrd[i,j] )\n        s<- s+size[i]\n      }\n      q <- quantile(g[, sc+j], probs = seq(0,1,length.out =  podim[j]+1))[-c(1,podim[j]+1)]\n      g[,sc+j] <- cut(g[, sc+j], breaks = c( -Inf, q, Inf))\n\n    }\n\n    stat  <- stat %>%\n      cbind(centerOrd = centerOrd) %>%\n      cbind(varOrd = varOrd)\n  }\n\n  sc = sc + ord\n\n  ## nominal\n  if(nom >0){\n    # podim\n    if(is.null(ppdim) || length(ppdim) != nom)\n      ppdim <-  sample(2:6, nom, replace = TRUE)\n\n    if(!is.null(paraNom) && length(paraNom) == nom && sapply(paraNom, dim ) == rbind(ngroup, ppdim))\n      paraNom <- paraNom\n    else{\n      for(j in 1:nom){\n        r <- matrix(runif(ppdim[j] *ngroup),nrow = ngroup)\n        paraNom[[j]] <- r/rowSums(r)\n      }\n    }\n\n    s <- 0\n    for(i in 1:ngroup){\n      for(j in 1:nom){\n        g[(s+1):(s+size[i]), sc+j] <- sample(1:ppdim[j], size[i], prob = paraNom[[j]][i,], replace = TRUE)\n      }\n      s <- s + size[i]\n    }\n\n    for(i in 1:nom){\n      stat[[paste0(\"paraNom_\",i)]] = paraNom[[i]]\n    }\n\n  }\n\n  sc = sc + nom\n  # count\n  if(count >0 ){\n\n    if(is.null(lambda) || dim(lambda) != c(ngroup, count))\n      lambda <- matrix(runif(ngroup*count) , nrow = ngroup)\n\n    s <- 0\n    for(i in 1:ngroup){\n      for(j in 1:count){\n        g[(s+1):(s+size[i]), sc+j] <- rpois(size[i], lambda[i,j])\n      }\n      s <- s+size[i]\n    }\n\n    stat <- stat %>% cbind(lambda = lambda)\n\n  }\n\n\n\n\n\n  return(list(data = g, statistics =stat ))\n\n}\n\n#######example\n\n\ngg <- simuData(3, size = c(100,100,100), cont = 3, ord = 2,  nom =3, count=3,seed=1,\n               podim = c(6,3), ppdim = c(3,3))\nlibrary(foreign)\nwrite.foreign(as.data.frame(gg$data), \"mydata.txt\", \"mydata.sps\", package=\"SPSS\")\n\ndf <- as.data.frame(t(gg$statistics))\ndf\nd <- as.data.frame(gg$data)\nsumma1 <- d %>% group_by(V_Cluster) %>%\n  summarise(mean = mean(V4_Ord), median = median(V4_Ord),\n            n1 = sum(V4_Ord == 1),  n2 = sum(V4_Ord == 2),  n3 = sum(V4_Ord == 3), n = n())\nsumma1\n\nsumma2 <- d %>% group_by(V_Cluster) %>%\n  summarise(mean = mean(V5_Ord), median = median(V5_Ord),\n            n1 = sum(V5_Ord == 1),  n2 = sum(V5_Ord == 2),  n3 = sum(V5_Ord == 3), n = n())\nsumma2\n\ncc <- data.recode(gg$data[,-1], continuous = 1:3)\ncc <- data.recode(gg$data[,-1], continuous = 1:3, ordinal = 4:5)\ncc <- data.recode(gg$data[,-1], continuous = 1:3, nominal = 4:5)\ncc <- data.recode(gg$data[,-1], continuous = 1:5)\ncc <- data.recode(gg$data[,-1], continuous = 1:3, nominal = 6:8)\ncc <- data.recode(gg$data[,-1], continuous = 1:3, nominal = 6:8, count = 9:11)\ncc <- data.recode(gg$data[,-1], continuous = 1:3, ordinal = 4:5, nominal = 6:8, count = 9:11)\ncc <- data.recode(gg$data[,-1], nominal = 4)\ncc <- data.recode(gg$data[,-1], ordinal = 4)\ncc <- data.recode(gg$data[,-1], continuous = 4)\n\ncc$data\nfcm <- initFlexmix(cc$data ~ 1, k = 2:5, nrep=10,\n                   model = mcmixed(continuous = cc$con.len,\n                                   ordinal = cc$ord.len,\n                                   nominal = cc$nom.len,\n                                   count.poi = cc$count.len,\n                                   ppdim = cc$ppdim[1:cc$nom.len],\n                                   pred.ordinal = FALSE,\n                                   diagonal = TRUE),\n                   control = list(minprior =0.1))\n\n\nfcm\nplot(fcm)\nm <- getModel(fcm, which=\"3\")\nm\nprofile(m,gg)\nt1 = table(gg$data[,1],m@cluster)\nt1\ntable(gg$data[,5],m@cluster)\ntable(gg$data[,1],gg$data[,5])\nt2 = table(gg$data[,1],m@cluster)\nt2\n\n\n#############\n\n\ncenter = NULL; var = NULL\ncenterOrd = NULL; varOrd = NULL; podim = NULL\nparaNom = NULL; ppdim = NULL\nlambda = NULL\ncenter <- t(df[2:4,])\n\ng1 <- simuData(5, size = c(100,100,100,100), cont = 3, ord = 2,  nom =3,count=3,\n               center = center, var = var,\n               centerOrd = centerOrd, varOrd = varOrd, podim = podim,\n               paraNom = paraNom, ppdim = ppdim,\n               lambda = lambda)\ng1\n\ncc <- data.recode(gg$data[,-1], continuous = 1:3,  nominal = 6:8)\ncc <- data.recode(gg$data[,-1], continuous = 1:3, nominal = 6:8, count = 9:11)\ncc <- data.recode(gg$data[,-1], continuous = 1:3, ordinal = 4:5, nominal = 6:8, count = 9:11)\n\nfcm <- initFlexmix(cc$data ~ 1, k = 2:5,\n                   model = mcmixed(continuous = cc$con.len,\n                                   ordinal = cc$ord.len,\n                                   nominal = cc$nom.len,\n                                   count.poi = cc$count.len,\n                                   ppdim = cc$ppdim[1:cc$nom.len],\n                                   pred.ordinal = TRUE,\n                                   diagonal = TRUE))\nfcm\nplot(fcm)\nm <- getModel(fcm, which=\"3\")\nm\nt1 = table(gg$data[,1],m@cluster)\nt2 = table(gg$data[,1],m@cluster)\ngg$statistics\n\n\n?getModel\n\n\n\n\nlibrary(\"dplyr\")\nz <- data.frame(a=1:2)\nz %>% mutate(b=a^2) -> z2\nif (z2$b[1]>1) {\n  z2 %>% mutate(b=b^2) -> z2\n}\nz2 %>% mutate(b=b^2) -> z3\n",
    "created" : 1469553218753.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3585033892",
    "id" : "A8D2BC20",
    "lastKnownWriteTime" : 1469554049,
    "last_content_update" : 1469554049602,
    "path" : "~/Desktop/customer segmentation/07.05 Shiny/example.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}